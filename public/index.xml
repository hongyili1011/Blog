<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程之路 on 编程之路</title>
    <link>http://vonzhou.com/</link>
    <description>Recent content in 编程之路 on 编程之路</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 03 Apr 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>HBase 查询优化</title>
      <link>http://vonzhou.com/2019/hbase-query-optimize/</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://vonzhou.com/2019/hbase-query-optimize/</guid>
      <description>

&lt;h2 id=&#34;场景&#34;&gt;场景&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&#34;http://vonzhou.com/2019/hbase-page/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;《HBase 实现分页查询》&lt;/a&gt;中描述了一个按用户维度和时间区间查询HBase的场景，业务不断复杂后衍生出了另一个场景：需要查询一段时间段内，一个列符合特定条件的数据。&lt;/p&gt;

&lt;p&gt;假设我们要查询的数据领域模型如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class BigMsg {
    private Long id;
    private Long insertTime;
    private List&amp;lt;Long&amp;gt; a;
    private Long b;
    private String c;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题抽象为：从HBase查询列b=b0的数据，其中b很稀疏。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Long b0 = 123;
getDetailMsgs(b0);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;行键设计与查询性能&#34;&gt;行键设计与查询性能&lt;/h2&gt;

&lt;p&gt;HBase使用时最重要的莫过于Rowkey的设计，直接影响数据的存储和查询性能。&lt;/p&gt;

&lt;p&gt;在我们的场景中，为了实现按照时间区间查询，rowkey包括用户ID和时间戳，可以使用过滤器，Scan的时候取我们需要的数据，在数据量很大的情况下，大量的KeyValue会送到过滤器筛选，必然很低效。&lt;/p&gt;

&lt;h2 id=&#34;经验法则&#34;&gt;经验法则&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;rowkey不宜过长&lt;/li&gt;
&lt;li&gt;尽量将查询的维度或信息存储在rowkey中，因为rowkey筛选数据的效率最高&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面这张图来源于《HBase权威指南》，展示了KeyValue的各个方面对筛选数据性能的影响。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://vonzhou.com/images/hbase-query-optimize-1.png&#34; alt=&#34;从左到右查询性能逐渐降低&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;优化方案&#34;&gt;优化方案&lt;/h2&gt;

&lt;p&gt;回到我们的问题上来。&lt;/p&gt;

&lt;p&gt;要查询一段时间内，列b=b0的数据，能想到有3种方法。&lt;/p&gt;

&lt;h3 id=&#34;使用filter&#34;&gt;使用Filter&lt;/h3&gt;

&lt;p&gt;最直接的想法是Scan的时候设置列值过滤器，但是列b稀疏，所以在这样的效率很低。&lt;/p&gt;

&lt;h3 id=&#34;rowkey中包含&#34;&gt;rowkey中包含&lt;/h3&gt;

&lt;p&gt;可以在设计rowkey的时候纳入列b的信息，这样方法存在以下缺陷：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;会增加rowkey的存储开销&lt;/li&gt;
&lt;li&gt;一开始设计rowkey的时候，并不能考虑到所有类似情况，所以灵活性不好&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;映射表&#34;&gt;映射表&lt;/h3&gt;

&lt;p&gt;本人在实际中采用的是引入一个映射表的方法，映射表中存储了对应的列b和Msg HTable的rowkey之间的关联信息。&lt;/p&gt;

&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;

&lt;h3 id=&#34;映射信息存储&#34;&gt;映射信息存储&lt;/h3&gt;

&lt;p&gt;BigMsg信息的存储见《HBase 实现分页查询》，之后需要同时更新映射信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void saveMapInfo(BigMsg msg, String msgRowkey) {
    Long b = msg.getB();
    Long insertTime = msg.getInsertTime();
    // 将id作为rowkey的一部分，防止分布式环境下重复
    Long id = msg.getId();
    try {
        Table table = getTable();
 		Put p = new Put(getRowKey(b, insertTime, id));
        p.addColumn(Bytes.toBytes(COL_FAMILY), 			Bytes.toBytes(MSG_ID_COL), Bytes.toBytes(msgRowkey));
        table.put(put);
    } catch (Exception e) {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查询&#34;&gt;查询&lt;/h3&gt;

&lt;p&gt;有了映射表，查询的时候就按时间范围先从映射表的时候Scan得到BigMsg HTable的rowkey，然后根据rowkey，使用批量Get从BigMsg HTable中查询得到最终的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void getDetailMsgs(Long b) throws Exception {
    // 全量的
    long start = 0L;
    long end = System.currentTimeMillis();

    Filter filter = new PageFilter(100);

    byte[] lastRow = null;
    byte[] startRow = getRowKey(b, end, 0L);
    byte[] endRow = getRowKey(b, start, Long.MAX_VALUE);

	// 映射表
    Table table = getTable();
    while (true) {
        Scan scan = new Scan();
        scan.setFilter(filter);

        byte[] sr = null;
        if (lastRow != null) {
            sr = Bytes.add(lastRow, new byte[1]);
        } else {
            sr = startRow;
        }

        scan.setStartRow(sr);
        scan.setStopRow(endRow);
        ResultScanner scanner = table.getScanner(scan);
        Result result = null;
        int cnt = 0;
        List&amp;lt;String&amp;gt; msgRowkeys = new ArrayList&amp;lt;&amp;gt;();
        while ((result = scanner.next()) != null) {
            String rk = HBaseBytesUtil.getString(result.getValue(Bytes.toBytes(COL_FAMILY), Bytes.toBytes(&amp;quot;id&amp;quot;)));
            msgRowkeys.add(rk);
            cnt++;
            lastRow = result.getRow();
        }
        if (CollectionUtils.isNotEmpty(msgRowkeys)) {
            List&amp;lt;BigMsg&amp;gt; msgs = multiGet(msgRowkeys);
            // 处理 Msgs
            }
        }
        scanner.close();
        if (cnt == 0) {
            break;
        }
    }
}

public List&amp;lt;BigMsg&amp;gt; multiGet(List&amp;lt;String&amp;gt; msgRowkeys) throws Exception {
    List&amp;lt;BigMsg&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    Table table = getMsgTable();

    List&amp;lt;Get&amp;gt; gets = new ArrayList&amp;lt;&amp;gt;();
    for (String r : msgRowkeys) {
        Get g = new Get(Bytes.toBytes(r));
        g.addFamily(Bytes.toBytes(COL_FAMILY));
        gets.add(g);
    }
    Result[] rs = table.get(gets);
    if (ArrayUtils.isNotEmpty(rs)) {
        for (Result r : rs) {
            res.add(getMsgFromResult(r));
        }
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;充分挖掘应用场景，这样才能设计出良好的rowkey&lt;/li&gt;
&lt;li&gt;使用映射表，其实也是变相的把需要检索的列移到了rowkey中，只不过是映射表的rowkey，这样可以不影响原始HTable的rowkey&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>《Youth》</title>
      <link>http://vonzhou.com/2019/youth/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://vonzhou.com/2019/youth/</guid>
      <description>

&lt;p&gt;无意间看到《Youth》这首诗，瞬间想到六，七年前有段时间那个在黄家湖畔每天学习英文的少年，其中就有背诵这首诗。&lt;/p&gt;

&lt;h2 id=&#34;原文&#34;&gt;原文&lt;/h2&gt;

&lt;p&gt;Youth is not a time of life—it is a state of mind.&lt;/p&gt;

&lt;p&gt;It is not a matter of red cheeks, red lips and supple knees.&lt;/p&gt;

&lt;p&gt;It is a temper of the will; a quality of the imagination; a vigor(精力) of the emotions.&lt;/p&gt;

&lt;p&gt;it is a freshness of the deep springs of life.&lt;/p&gt;

&lt;p&gt;Youth means a temperamental predominance of courage over timidity,&lt;/p&gt;

&lt;p&gt;of the appetite for adventure over a life of ease.&lt;/p&gt;

&lt;p&gt;This often exists in a man of fifty, more than in a boy of twenty.&lt;/p&gt;

&lt;p&gt;Nobody grows old by merely living a number of years;&lt;/p&gt;

&lt;p&gt;people grow old by deserting their ideals.&lt;/p&gt;

&lt;p&gt;Years may wrinkle the skin, but to give up enthusiasm wrinkles the soul.&lt;/p&gt;

&lt;p&gt;Worry, doubt, self-distrust, fear and despair—&lt;/p&gt;

&lt;p&gt;these are the long, long years that bow the head  and turn the growing spirit back to dust.&lt;/p&gt;

&lt;p&gt;Whether seventy or sixteen, there is in every being’s heart a love of wonder;&lt;/p&gt;

&lt;p&gt;the sweet amazement at the stars and starlike things and thoughts;&lt;/p&gt;

&lt;p&gt;the undaunted challenge of events,&lt;/p&gt;

&lt;p&gt;the unfailing childlike appetite for what comes next,&lt;/p&gt;

&lt;p&gt;and the joy in the game of life.&lt;/p&gt;

&lt;p&gt;You are as young as your faith, as old as your doubt;&lt;/p&gt;

&lt;p&gt;as young as your self-confidence, as old as your fear,&lt;/p&gt;

&lt;p&gt;as young as your hope, as old as your despair.&lt;/p&gt;

&lt;p&gt;In the central place of your heart there is a wireless station.&lt;/p&gt;

&lt;p&gt;So long as it receives messages of beauty, hope, cheer, grandeur, courage,&lt;/p&gt;

&lt;p&gt;and power from the earth, from men and from the Infinite—so long are you young.&lt;/p&gt;

&lt;p&gt;When the wires are all down and the central places of your heart are covered with the&lt;/p&gt;

&lt;p&gt;snows of pessimism and the ice of cynicism,&lt;/p&gt;

&lt;p&gt;then are you grown old, indeed!
                                                                               –Samuel  Ullman&lt;/p&gt;

&lt;h2 id=&#34;中文&#34;&gt;中文&lt;/h2&gt;

&lt;p&gt;青春不是年华，而是心境；&lt;/p&gt;

&lt;p&gt;青春不是桃面、丹唇、柔膝，&lt;/p&gt;

&lt;p&gt;而是深沉的意志，恢宏的想象，炙热的感情；&lt;/p&gt;

&lt;p&gt;青春是生命的深泉在涌流。&lt;/p&gt;

&lt;p&gt;青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。&lt;/p&gt;

&lt;p&gt;如此锐气，二十后生而有之，六旬男子则更多见。&lt;/p&gt;

&lt;p&gt;年岁有加，并非垂老，理想丢弃，方堕暮年。&lt;/p&gt;

&lt;p&gt;岁月悠悠，衰微只及肌肤；热忱抛却，颓废必致灵魂。&lt;/p&gt;

&lt;p&gt;忧烦，惶恐，丧失自信，定使心灵扭曲，意气如灰。&lt;/p&gt;

&lt;p&gt;无论年届花甲，抑或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。&lt;/p&gt;

&lt;p&gt;人人心中皆有一台天线，只要你从天上人间接受美好、希望、欢乐、勇气和力量的信号，你就青春永驻，风华常存。&lt;/p&gt;

&lt;p&gt;一旦天线下降，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即使年方二十，实已垂垂老矣；&lt;/p&gt;

&lt;p&gt;然则只要树起天线，捕捉乐观信号，你就有望在八十高龄告别尘寰时仍觉年轻。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JDK 12新特性：Switch表达式</title>
      <link>http://vonzhou.com/2019/java12-switch-expression/</link>
      <pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://vonzhou.com/2019/java12-switch-expression/</guid>
      <description>

&lt;p&gt;JDK 12 GA在2019.3.19发布，其中一项新特性是JEP 325：Switch表达式（Switch Expressions）。学习下。&lt;/p&gt;

&lt;p&gt;如果知道Scala中的模式匹配，就很容易理解Switch表达式。&lt;/p&gt;

&lt;p&gt;本文完整代码见&lt;a href=&#34;https://github.com/vonzhou/learning-java12/blob/master/src/main/java/com/vonzhou/learningjava12/SwitchDemo.java&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;SwitchDemo &lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;传统的switch语句&#34;&gt;传统的Switch语句&lt;/h2&gt;

&lt;p&gt;传统的Switch语句（switch statement）我们并不陌生，在每个case分支中实现对应的处理逻辑。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static void switchStatement(WeekDay day) {
    int numLetters = 0;
    switch (day) {
        case MONDAY:
        case FRIDAY:
        case SUNDAY:
            numLetters = 6;
            break;
        case TUESDAY:
            numLetters = 7;
            break;
        case THURSDAY:
        case SATURDAY:
            numLetters = 8;
            break;
        case WEDNESDAY:
            numLetters = 9;
            break;
    }
    System.out.println(&amp;quot;1. Num Of Letters: &amp;quot; + numLetters);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Switch语句的特点是每个case分支块是没有返回值的，而表达式（expression）的特点是有返回值。&lt;/p&gt;

&lt;h2 id=&#34;switch表达式&#34;&gt;Switch表达式&lt;/h2&gt;

&lt;h3 id=&#34;模式匹配-patrern-matching&#34;&gt;模式匹配（Patrern Matching）&lt;/h3&gt;

&lt;p&gt;上述“计算字符个数”的例子使用Switch表达式，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static void switchExpression(WeekDay day) {
    int numLetters = switch (day) {
        case MONDAY, FRIDAY, SUNDAY -&amp;gt; 6;
        case TUESDAY -&amp;gt; 7;
        case THURSDAY, SATURDAY -&amp;gt; 8;
        case WEDNESDAY -&amp;gt; 9;
    };

    System.out.println(&amp;quot;2. Num Of Letters: &amp;quot; + numLetters);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Switch表达式目前属于预览（Preview）功能，所以在编译运行的时候需要通过&lt;code&gt;--enable-preview&lt;/code&gt;选项设置来开启，具体方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;D:\GitHub\learning-java12\src\main\java
λ D:\dev\jdk-12\bin\javac.exe --enable-preview --release 12 com\vonzhou\learningjava12\SwitchDemo.java
注: com\vonzhou\learningjava12\SwitchDemo.java 使用预览语言功能。
注: 有关详细信息，请使用 -Xlint:preview 重新编译。

D:\GitHub\learning-java12\src\main\java
λ D:\dev\jdk-12\bin\java.exe --enable-preview com.vonzhou.learningjava12.SwitchDemo
1. Num Of Letters: 6
2. Num Of Letters: 9
3. Num Of Letters: 8
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;break-可以返回值&#34;&gt;break 可以返回值&lt;/h3&gt;

&lt;p&gt;Switch表达式中也支持break有返回值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static void switchExpressionBreakReturn(WeekDay day) {
    int numLetters = switch (day) {
        case MONDAY:
        case FRIDAY:
        case SUNDAY:
            break 6;
        case TUESDAY:
            break 7;
        case THURSDAY:
        case SATURDAY:
            numLetters = 8;
            break 8;
        case WEDNESDAY:
            break 9;
    };

    System.out.println(&amp;quot;3. Num Of Letters: &amp;quot; + numLetters);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;scala中的模式匹配&#34;&gt;Scala中的模式匹配&lt;/h2&gt;

&lt;p&gt;Scala中实现模式匹配的语法是Match表达式，其实可以看做是Java中的Switch表达式。例如判断一个列表的第一个元素是否是0，可以实现为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Scala&#34;&gt;def startsWithZero(expr: List[Int]) =
expr match {
  case List(0, _*) =&amp;gt; println(&amp;quot;found it&amp;quot;)
  case _ =&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;Switch表达式可以使得写出的代码更加简洁安全（more concisely and safely）。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://openjdk.java.net/jeps/325&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JEP 325: Switch Expressions (Preview)&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>http://vonzhou.com/about/</link>
      <pubDate>Mon, 18 Mar 2019 10:23:42 +0800</pubDate>
      
      <guid>http://vonzhou.com/about/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;2013~2016 武汉，研究生&lt;/li&gt;
&lt;li&gt;2009~2013 武汉，大学&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>我的读书历程</title>
      <link>http://vonzhou.com/readings/</link>
      <pubDate>Mon, 18 Mar 2019 10:23:42 +0800</pubDate>
      
      <guid>http://vonzhou.com/readings/</guid>
      <description>

&lt;h2 id=&#34;computer-science-计算机科学&#34;&gt;Computer Science 计算机科学&lt;/h2&gt;

&lt;h3 id=&#34;basics-通识-基础-经典&#34;&gt;Basics 通识/基础/经典&lt;/h3&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 《A Philosophy of Software Design》 &lt;a href=&#34;https://www.youtube.com/watch?v=bmSAYlu0NcY&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;视频&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《程序员修炼之道 从小工到专家》  2017.11.14    👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 《代码大全》&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《深入理解计算机系统 第2版》| &lt;a href=&#34;https://github.com/vonzhou/CSAPP&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;代码&lt;/a&gt; 👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《TCP/IP详解卷1：协议》&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《重构 改善既有代码的设计》&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;linux-unix&#34;&gt;Linux/Unix&lt;/h3&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 《性能之巅:洞悉系统、企业与云计算》&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《Unix环境高级编程》APUE 👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《Unix网络编程卷1：套接字联网API》 👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《Unix网络编程卷2：进程间通信》 👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《深入理解Linux内核》 👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《Linux内核设计与实现 第3版》&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;java&#34;&gt;Java&lt;/h3&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《RocketMQ实战与原理解析》2019.1.27&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《分布式Java应用 : 基础与实践》2019.1.25&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《实战Java高并发程序设计》| &lt;a href=&#34;https://github.com/vonzhou/learning-java/tree/master/src/PracticeJavaHighConcurrency&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;代码&lt;/a&gt;   2018.11.6 👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《深入剖析Tomcat》 2018.10.28 👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《MyBatis技术内幕》 2018.10.20 👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《HotSpot实战》 2018.3.14 👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《Java并发编程实战》| &lt;a href=&#34;https://github.com/vonzhou/JavaConcurrencyInPractice&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;代码&lt;/a&gt;  2018.2.25  👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《深入理解Java虚拟机（第2版）》| &lt;a href=&#34;https://github.com/vonzhou/learning-java/tree/master/src/jvm&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;代码&lt;/a&gt;  👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《大型网站系统与Java中间件实践》  2018.5.22&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《Java 8实战》| &lt;a href=&#34;https://github.com/vonzhou/Java8InAction&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;代码&lt;/a&gt; 2017.11.7&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;scala&#34;&gt;Scala&lt;/h3&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 《Scala编程（第3版）》     👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《快学Scala》&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;golang&#34;&gt;Golang&lt;/h3&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《Go语言实战》 2018.7.5&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;bigdata-大数据&#34;&gt;BigData 大数据&lt;/h3&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《Spark快速大数据分析》 2019.3.13&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《HBase权威指南》 2018.12.20&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《HBase不睡觉书》2018.11.3&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《Storm分布式实时计算模式》 2018.10.13&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《Hadoop: The Definitive Guide : 4th Edition》 2018.10.7  👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《Kafka权威指南》 2018.6.15 👍&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;database-数据库&#34;&gt;Database 数据库&lt;/h3&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 《高性能MySQL》 👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《MySQL技术内幕 InnoDB存储引擎》 👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《Redis设计与实现》&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《Redis开发与运维》  2017.11.12&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;architecture-架构&#34;&gt;Architecture 架构&lt;/h3&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 《系统架构:复杂系统的产品设计与开发》&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 《大型网站技术架构：核心原理与案例分析》&lt;br /&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《Clean Architecture》 2019.1.8 👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《Designing Data-Intensive Applications》 2018.1.30 👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《大型网站技术架构演进与性能优化》 2018.10.10&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《大型分布式网站架构设计与实践》 2017.2.21&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;entrepreneurship-创业-管理&#34;&gt;Entrepreneurship 创业/管理&lt;/h2&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《重来 Rework》&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;history-历史&#34;&gt;History 历史&lt;/h2&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《中国历代政治得失》 2019.2.23  👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 《巨流河 台版》&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《紫禁城的黄昏》&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《万历十五年》   2017.11.12  👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《明朝那些事儿》&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;literature-文学&#34;&gt;Literature 文学&lt;/h2&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 王小波《沉默的大多数》    2019.3.11   👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《活着为了讲述》  2017.4.10   👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《百年孤独》   2018.2.18  👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《相约星期二》&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《解忧杂货店》&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《活着》   👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《围城》  👍&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《巨人的陨落》  2017.3.10&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;biography-传记&#34;&gt;Biography 传记&lt;/h2&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《DOOM启世录》 2017.12.4&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;thinking-思维&#34;&gt;Thinking 思维&lt;/h2&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《如何阅读一本书》 👍&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;finance-金融&#34;&gt;Finance 金融&lt;/h2&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 《世界上最简单的会计书》  2019.3.20&lt;br /&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 周夏飞《公司理财》&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 唐朝《手把手教你读财报2》&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>波兰来客</title>
      <link>http://vonzhou.com/2019/bo-lan-lai-ke/</link>
      <pubDate>Fri, 15 Mar 2019 11:03:31 +0800</pubDate>
      
      <guid>http://vonzhou.com/2019/bo-lan-lai-ke/</guid>
      <description>&lt;p&gt;很喜欢这首诗。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;波兰来客 
         —北岛
那时我们有梦， 
关于文学， 
关于爱情， 
关于穿越世界的旅行。 
如今我们深夜饮酒， 
杯子碰到一起， 
都是梦破碎的声音。
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>HBase 实现分页查询</title>
      <link>http://vonzhou.com/2019/hbase-page/</link>
      <pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://vonzhou.com/2019/hbase-page/</guid>
      <description>

&lt;h2 id=&#34;序&#34;&gt;序&lt;/h2&gt;

&lt;p&gt;按时间区间分页导出HBase中的数据。&lt;/p&gt;

&lt;h2 id=&#34;rowkey的设计&#34;&gt;Rowkey的设计&lt;/h2&gt;

&lt;p&gt;在使用HBase时，Rowkey的设计很重要，取决于业务。&lt;/p&gt;

&lt;p&gt;比如要把用户关联的数据存入HBase，后续根据时间查询，可以这样设计rowkey：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;userId + (Long.MAX - timestamp) + uid 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样能满足：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以根据userId的特点预分区&lt;/li&gt;
&lt;li&gt;时间戳逆转，可以保证最近的数据rowkey排序靠前&lt;/li&gt;
&lt;li&gt;分布式环境下时间戳可能一样，所以追加一个UID，防止重复&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private String getRowKeyStr(String userId, long ts, long uid) {
    return String.format(&amp;quot;%s%013d%019d&amp;quot;, userId, Long.MAX_VALUE - ts, uid);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;构造table实例&#34;&gt;构造Table实例&lt;/h2&gt;

&lt;p&gt;需要自己保证Table的线程安全性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Table getTable() throws Exception {
    Table table = tableThreadLocal.get();
    if (table == null) {
        table = getTableInternal();
        if (table != null) {
            tableThreadLocal.set(table);
        }
    }
    return table;
}

public Table getTableInternal() throws Exception {
    Configuration config = HBaseConfiguration.create();
    config.set(HConstants.ZOOKEEPER_QUORUM, hBaseConfig.getZkQuorum());
    config.set(HConstants.ZOOKEEPER_CLIENT_PORT, hBaseConfig.getZkClientPort());
    config.set(HConstants.ZOOKEEPER_ZNODE_PARENT, hBaseConfig.getZkZnodeParent());
    config.setInt(&amp;quot;hbase.rpc.timeout&amp;quot;, 20000);
    config.setInt(&amp;quot;hbase.client.operation.timeout&amp;quot;, 30000);
    config.setInt(&amp;quot;hbase.client.scanner.timeout.period&amp;quot;, 20000);
    config.setInt(&amp;quot;hbase.client.pause&amp;quot;, 50);
    config.setInt(&amp;quot;hbase.client.retries.number&amp;quot;, 15);
//        HBaseAdmin.checkHBaseAvailable(config);

    Connection connection = ConnectionFactory.createConnection(config);
    Table table = connection.getTable(TableName.valueOf(hBaseConfig.getTableName()));

    return table;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;分页查询&#34;&gt;分页查询&lt;/h2&gt;

&lt;p&gt;这里要注意是Scan中的startRow，stopRow是左闭右开区间，所以为了避免下一页中包含上一页的最后一条数据， 下一页Scan的时候startRow追加了一个0字节。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Filter filter = new PageFilter(15);

byte[] lastRow = null;
byte[] startRow = getRowKey(userId, end, 0L);
byte[] endRow = getRowKey(userId, start, Long.MAX_VALUE);

Table table = getTable();
if (table == null) {
    return;
}

int sum = 0;

while (true) {
    Scan scan = new Scan();
    scan.setFilter(filter);

    byte[] sr = null;
    if (lastRow != null) {
        sr = Bytes.add(lastRow, new byte[1]);// 重点1
    } else {
        sr = startRow;
    }
    scan.setStartRow(sr);
    scan.setStopRow(endRow);
    ResultScanner scanner = table.getScanner(scan);
    Result result = null;
    int cnt = 0;
    while ((result = scanner.next()) != null) {
        // 从Result中解析数据，进行处理
        cnt++;
        lastRow = result.getRow();
    }
    scanner.close();
    if (cnt == 0) {
        break;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;filter&#34;&gt;Filter&lt;/h2&gt;

&lt;p&gt;上述只是用了PageFilter实现分页，如果需要根据列的各种条件进行查询，就需要用到FilterList，或者自己实现Filter。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>记一次使用KafkaProducer引发的Full GC问题</title>
      <link>http://vonzhou.com/2019/kafka-producer-fullgc-story/</link>
      <pubDate>Fri, 01 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://vonzhou.com/2019/kafka-producer-fullgc-story/</guid>
      <description>

&lt;h2 id=&#34;场景&#34;&gt;场景&lt;/h2&gt;

&lt;p&gt;一个模块接收数据，然后投到Kafka中，实现削峰填谷。突然有一天频繁出现Full GC问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://vonzhou.com/images/kafka-producer-fullgc-story-1.gif&#34; alt=&#34;FullGC情况&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;初步尝试&#34;&gt;初步尝试&lt;/h2&gt;

&lt;p&gt;查看JVM的配置，发现最大堆配置的太小，推测：堆内存不足，导致频繁gc，内存不足，导致往kafka发送消息的时候阻塞，所以线程都会卡住。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;15302 com.xxxx.AppRunner -Dlog.dir=/path/to/logs -Xms1024m -Xmx1024m -XX:MaxPermSize=256m -verbose:gc -XX:+PrintGCDetails
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调整堆大小配置后，Full GC 问题并没有得到缓解。&lt;/p&gt;

&lt;h2 id=&#34;mat分析&#34;&gt;MAT分析&lt;/h2&gt;

&lt;p&gt;heap dump出现使用MAT分析。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://vonzhou.com/images/kafka-producer-fullgc-story-2.png&#34; alt=&#34;MAT分析&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里的大对象都是我们发送的批量消息对象，推测：是不是&lt;code&gt;batch.size&lt;/code&gt;设置的过大？（设置的是40MB）&lt;/p&gt;

&lt;h2 id=&#34;解决方法&#34;&gt;解决方法&lt;/h2&gt;

&lt;p&gt;调小&lt;code&gt;batch.size&lt;/code&gt;，设置为20MB：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;props.put(&amp;quot;buffer.memory&amp;quot;, 100 * 1024 * 1024);
// 批量发送的字节大小， 20MB
props.put(&amp;quot;batch.size&amp;quot;, 2 * 10 * 1024 * 1024);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终问题得以解决，连Minor GC也很少了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://vonzhou.com/images/kafka-producer-fullgc-story-3.png&#34; alt=&#34;GC趋势图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;kafkaproducer消息发送过程&#34;&gt;KafkaProducer消息发送过程&lt;/h2&gt;

&lt;p&gt;KafkaProducer发送消息的过程是：消息追加到一个内部的队列中，有一个异步线程负责从中取出，将消息发送给Broker。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://vonzhou.com/images/kafka-producer-fullgc-story-4.jpg&#34; alt=&#34;Producer发送消息流程&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在了解kafka消息发送过程的基础上，通过MAT大对象图还可以看到：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;buffer.memory&lt;/code&gt;配置的是客户端发送消息时&lt;code&gt;BufferPool&lt;/code&gt;的内存大小，至少要比&lt;code&gt;batch.size&lt;/code&gt;大，否则连一个&lt;code&gt;RecordBatch&lt;/code&gt;也放不进去。&lt;/li&gt;
&lt;li&gt;实际占用的内存可能是&lt;code&gt;buffer.memory&lt;/code&gt;的好几倍（4~5倍？），流转多个环节，底层存储都是&lt;code&gt;ByteBuffer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>BeanUtils.copyProperties 源码分析</title>
      <link>http://vonzhou.com/2019/spring-beanutils-copyproperties/</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://vonzhou.com/2019/spring-beanutils-copyproperties/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;利用反射&lt;/li&gt;
&lt;li&gt;字段不一致也不会报错，因为会根据目标对象的属性去源对象中找对应的属性描述符，存在才拷贝&lt;/li&gt;
&lt;li&gt;相同字段，类型不同，也不会有问题，因为拷贝之时会判断该字段源对象的读方法返回值，是否可应用用目标对象的写方法参数&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CopyPropertiesDemo {

    public static void main(String[] args) {

        Student s = new Student();
        s.setName(&amp;quot;vz&amp;quot;);
        s.setFoo(1024);
        s.setBar(-1);

        Father f = new Father();
        BeanUtils.copyProperties(s, f);
        System.out.println(f);
    }

    static class Student{
        private String name;
        private int foo;
        private int bar;
        // setters and getters
    }


    static class Father{
        private String name;
        private int age;
        private int salary;
        private double foo;
        private Integer bar;
        // setters and getters

        @Override
        public String toString() {
            return &amp;quot;Father{&amp;quot; +
                    &amp;quot;name=&#39;&amp;quot; + name + &#39;\&#39;&#39; +
                    &amp;quot;, age=&amp;quot; + age +
                    &amp;quot;, salary=&amp;quot; + salary +
                    &amp;quot;, foo=&amp;quot; + foo +
                    &amp;quot;, bar=&amp;quot; + bar +
                    &#39;}&#39;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Father{name=&#39;vz&#39;, age=0, salary=0, foo=0.0, bar=-1}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;copyproperties-源码分析&#34;&gt;copyProperties 源码分析&lt;/h2&gt;

&lt;p&gt;copyProperties 的实现总体上很清晰：利用反射，调用source对象的get方法，然后set到target对象中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void copyProperties(Object source, Object target) throws BeansException {
		copyProperties(source, target, null, (String[]) null);
	}

private static void copyProperties(Object source, Object target, Class&amp;lt;?&amp;gt; editable, String... ignoreProperties)
			throws BeansException {
		Class&amp;lt;?&amp;gt; actualEditable = target.getClass();

		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);
		List&amp;lt;String&amp;gt; ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null);

		for (PropertyDescriptor targetPd : targetPds) {
			Method writeMethod = targetPd.getWriteMethod();
			if (writeMethod != null &amp;amp;&amp;amp; (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {
				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());
				if (sourcePd != null) {
					Method readMethod = sourcePd.getReadMethod();
					if (readMethod != null &amp;amp;&amp;amp;
							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {
						try {
							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {
								readMethod.setAccessible(true);
							}
							Object value = readMethod.invoke(source);
							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {
								writeMethod.setAccessible(true);
							}
							writeMethod.invoke(target, value);
						}
						catch (Throwable ex) {
							throw new FatalBeanException(
									&amp;quot;Could not copy property &#39;&amp;quot; + targetPd.getName() + &amp;quot;&#39; from source to target&amp;quot;, ex);
						}
					}
				}
			}
		}
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;获取-propertydescriptor&#34;&gt;获取 PropertyDescriptor&lt;/h2&gt;

&lt;p&gt;PropertyDescriptor 描述的是Java Bean的一个属性，具有读写(getter/setter)方法，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static PropertyDescriptor[] getPropertyDescriptors(Class&amp;lt;?&amp;gt; clazz) throws BeansException {
		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz);
		return cr.getPropertyDescriptors();
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;CachedIntrospectionResults&lt;/code&gt;缓存了Java Bean对应Class的&lt;code&gt;PropertyDescriptor&lt;/code&gt;信息，存储数据结构是&lt;code&gt;ConcurrentHashMap&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final ConcurrentMap&amp;lt;Class&amp;lt;?&amp;gt;, CachedIntrospectionResults&amp;gt; strongClassCache =
			new ConcurrentHashMap&amp;lt;Class&amp;lt;?&amp;gt;, CachedIntrospectionResults&amp;gt;(64);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先从缓存中查询，如果没有，则进行实际的解析，构造。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static CachedIntrospectionResults forClass(Class&amp;lt;?&amp;gt; beanClass) throws BeansException {
		CachedIntrospectionResults results = strongClassCache.get(beanClass);
		if (results != null) {
			return results;
		}
		results = softClassCache.get(beanClass);
		if (results != null) {
			return results;
		}

        // TODO 具体的解析过程
		results = new CachedIntrospectionResults(beanClass);
		ConcurrentMap&amp;lt;Class&amp;lt;?&amp;gt;, CachedIntrospectionResults&amp;gt; classCacheToUse;

        // TODO cachesafe ？
		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||
				isClassLoaderAccepted(beanClass.getClassLoader())) {
			classCacheToUse = strongClassCache;
		}
		else {
			classCacheToUse = softClassCache;
		}

		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results);
		return (existing != null ? existing : results);
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来看&lt;code&gt;CachedIntrospectionResults&lt;/code&gt;构造函数，先是利用&lt;code&gt;Introspector&lt;/code&gt;解析class的&lt;code&gt;BeanInfo&lt;/code&gt;（实现类是&lt;code&gt;GenericBeanInfo&lt;/code&gt;），然后更新缓存。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private CachedIntrospectionResults(Class&amp;lt;?&amp;gt; beanClass) throws BeansException {
		try {
			BeanInfo beanInfo = null;
			if (beanInfo == null) {
				// If none of the factories supported the class, fall back to the default
				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?
						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :
						Introspector.getBeanInfo(beanClass)); // 这里
			}
			this.beanInfo = beanInfo;


			this.propertyDescriptorCache = new LinkedHashMap&amp;lt;String, PropertyDescriptor&amp;gt;();

			// This call is slow so we do it once.
			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors();
			for (PropertyDescriptor pd : pds) {
				if (Class.class == beanClass &amp;amp;&amp;amp;
						(&amp;quot;classLoader&amp;quot;.equals(pd.getName()) ||  &amp;quot;protectionDomain&amp;quot;.equals(pd.getName()))) {
					// Ignore Class.getClassLoader() and getProtectionDomain() methods - nobody needs to bind to those
					continue;
				}
				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd);
				this.propertyDescriptorCache.put(pd.getName(), pd);
			}

			this.typeDescriptorCache = new ConcurrentReferenceHashMap&amp;lt;PropertyDescriptor, TypeDescriptor&amp;gt;();
		}
		catch (IntrospectionException ex) {
			throw new FatalBeanException(&amp;quot;Failed to obtain BeanInfo for class [&amp;quot; + beanClass.getName() + &amp;quot;]&amp;quot;, ex);
		}
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;判断是否可赋值-assignable&#34;&gt;判断是否可赋值（Assignable）&lt;/h2&gt;

&lt;p&gt;看工具类&lt;code&gt;ClassUtils&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static boolean isAssignable(Class&amp;lt;?&amp;gt; lhsType, Class&amp;lt;?&amp;gt; rhsType) {
		if (lhsType.isAssignableFrom(rhsType)) {
			return true;
		}
		if (lhsType.isPrimitive()) {
			Class&amp;lt;?&amp;gt; resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);
			if (lhsType == resolvedPrimitive) {
				return true;
			}
		}
		else {
			Class&amp;lt;?&amp;gt; resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);
			if (resolvedWrapper != null &amp;amp;&amp;amp; lhsType.isAssignableFrom(resolvedWrapper)) {
				return true;
			}
		}
		return false;
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;java.lang.Class.isAssignableFrom&lt;/code&gt;方法是native的，判断当前类型是否是另一个的超类，或者父接口，或者类型一样，可以看个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IsAssignableFromDemo {
    public static void main(String[] args) {
        System.out.println(Object.class.isAssignableFrom(Object.class)); // true
        System.out.println(Object.class.isAssignableFrom(String.class)); // true
        System.out.println(List.class.isAssignableFrom(ArrayList.class)); // true
        System.out.println(int.class.isAssignableFrom(long.class)); //false
        System.out.println(int.class.isAssignableFrom(int.class));//true
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;isAssignable&lt;/code&gt;同时也会考虑原始类型及包装类型的情况，比如 int a 可以被拷贝到另一个对象的 Integer a 中。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM垃圾回收总结</title>
      <link>http://vonzhou.com/2019/jvm-gc-summary/</link>
      <pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://vonzhou.com/2019/jvm-gc-summary/</guid>
      <description>

&lt;h2 id=&#34;1-垃圾回收算法&#34;&gt;1. 垃圾回收算法&lt;/h2&gt;

&lt;h3 id=&#34;mark-sweep-标记-清除-算法&#34;&gt;Mark-Sweep(标记-清除)算法&lt;/h3&gt;

&lt;h3 id=&#34;复制算法&#34;&gt;复制算法&lt;/h3&gt;

&lt;h3 id=&#34;mark-compact-标记-整理-算法&#34;&gt;Mark-Compact(标记-整理)算法&lt;/h3&gt;

&lt;h3 id=&#34;分代收集算法&#34;&gt;分代收集算法&lt;/h3&gt;

&lt;h2 id=&#34;2-垃圾收集器&#34;&gt;2. 垃圾收集器&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://vonzhou.com/images/gc-collectors.jpg&#34; alt=&#34;gc-collectors&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;新生代&#34;&gt;新生代&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Serial&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ParNew&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ParNew是Serial的多线程版本， 只有 Serial，ParNew能和CMS配合使用。ParNew是使用CMS后的默认新生代收集器，可以使用&lt;code&gt;-XX:+UseParNewGC&lt;/code&gt;强制指定。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Parallel Scavenge&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Parallel Scavenge收集器，吞吐量优先，通过参数可以控制最大垃圾收集的停顿时间（-XX:MaxGCPauseMills）及直接设置吞吐量大小（-XX:GCTimeRatio）。也可以开启GC自适应调节策略（GC Ergonomics）。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;XX:+UseParallelGC&lt;/code&gt;开启，JDK1.4.1引入。PS只能和Serial Old，ParOld搭配使用。&lt;/p&gt;

&lt;p&gt;Java 6，7，8 默认的收集器是Parallel GC（PS + Parallel Old），使用&lt;code&gt;PrintFlagsFinal&lt;/code&gt;可以看到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;$ ./bin/java -XX:+PrintFlagsFinal
bool UseParallelGC                            := true                                {product}
bool UseParallelOldGC                          = true                                {product}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;老年代&#34;&gt;老年代&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Serial Old&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Parallel Old&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Parallel Old收集器是PS的老年代版本，使用多线程和“标记-整理”。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;XX:+UseParallelOldGC&lt;/code&gt;开启后，也会自动设置&lt;code&gt;XX:+UseParallelGC&lt;/code&gt;，JDK5.0 update 6引入。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CMS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CMS收集器，以最短回收停顿时间，服务响应速度为目标，采用标记-清除算法。使用&lt;code&gt;-XX:+UseConcMarkSweepGC&lt;/code&gt;开启。&lt;/p&gt;

&lt;h3 id=&#34;g1收集器&#34;&gt;G1收集器&lt;/h3&gt;

&lt;p&gt;JDK7引入的&lt;/p&gt;

&lt;p&gt;G1收集器的Region，其他收集器新生代和老年代之间的对象引用，JVM都是使用Remembered Set来避免全堆扫描。&lt;/p&gt;

&lt;p&gt;Java 9,10默认的GC Collector是G1.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Getting Started with the G1 Garbage Collector&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;zgc&#34;&gt;ZGC&lt;/h4&gt;

&lt;p&gt;JDK11引入&lt;/p&gt;

&lt;p&gt;要完成的目标是：控制Java的垃圾回收时长在10ms以内，绝对不超过10ms，并且使用了该垃圾回收策略之后，吞吐对比当前Java缺省的垃圾回收策略G1，下降不超过15%&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.opsian.com/blog/javas-new-zgc-is-very-exciting/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Java&amp;rsquo;s new Z Garbage Collector (ZGC) is very exciting&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;TODO 使用不同的GC算法看GC日志&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://blogs.oracle.com/jonthecollector/our-collectors&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Our Collectors&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.fasterj.com/articles/oraclecollectors1.shtml&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Oracle JVM Garbage Collectors Available From JDK 1.7.0_04 And After&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>InnoDB 行锁的实现</title>
      <link>http://vonzhou.com/2019/innodb-row-lock/</link>
      <pubDate>Sat, 16 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://vonzhou.com/2019/innodb-row-lock/</guid>
      <description>

&lt;p&gt;InnoDB 实现行锁（row lock）的3种算法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Record Lock&lt;/code&gt;：单行记录上锁&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Gap Lock&lt;/code&gt;：间隙锁，锁定一个范围，不包括记录本身&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Next-key Lock&lt;/code&gt;：等价于&lt;code&gt;Gap Lock&lt;/code&gt; + &lt;code&gt;Record Lock&lt;/code&gt;，即锁定一个范围同时锁定记录本身，为了解决Phantom Problem。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;行加锁过程&#34;&gt;行加锁过程&lt;/h2&gt;

&lt;p&gt;InnoDB的行锁其实是索引记录锁，InnoDB存储引擎下每个表有一个主键（聚集索引），辅助索引中包含主键，根据查询使用的索引不同加锁也不同。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过主键加锁，仅对聚集索引记录进行加锁，&lt;code&gt;Record Lock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过辅助索引进行加锁，需要先对辅助索引加锁 &lt;code&gt;Gap Lock&lt;/code&gt;，再对聚集索引加锁 &lt;code&gt;Record Lock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当辅助索引是唯一索引的时候，&lt;code&gt;Next-key Lock&lt;/code&gt;会降级为 &lt;code&gt;Record Lock&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;

&lt;h3 id=&#34;唯一索引行锁定&#34;&gt;唯一索引行锁定&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table t (a int primary key);
insert into t values(1),(2),(5);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://vonzhou.com/images/innodb-row-lock-1.jpg&#34; alt=&#34;唯一索引行锁定&#34; /&gt;&lt;/p&gt;

&lt;p&gt;会话A会对a=5的行进行X锁定，由于a是主键且唯一，所以只会对这一行进行锁定，所以在会话B中插入a=4不会阻塞。&lt;/p&gt;

&lt;h3 id=&#34;辅助索引行锁定&#34;&gt;辅助索引行锁定&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table t2 (a int, b int, primary key(a), key(b));
insert into t2 values(1,1),(3,1),(5,3),(7,6),(10,8);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://vonzhou.com/images/innodb-row-lock-2.jpg&#34; alt=&#34;辅助索引行锁定-记录锁&#34; /&gt;&lt;/p&gt;

&lt;p&gt;会话A对a=5的聚簇索引行加了Record Lock，所以会话B会阻塞。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://vonzhou.com/images/innodb-row-lock-3.jpg&#34; alt=&#34;辅助索引行锁定-间隙锁&#34; /&gt;&lt;/p&gt;

&lt;p&gt;会话A不仅对a=5的聚簇索引行加了Record Lock，也会对辅助索引加 Next-Key Lock，锁定的范围是 (1,3],(3,6)。&lt;/p&gt;

&lt;p&gt;所以在会话B中执行&lt;code&gt;insert into t2 values(13,3);&lt;/code&gt;, &lt;code&gt;insert into t2 values(14,5);&lt;/code&gt;也是同样的情况。&lt;/p&gt;

&lt;p&gt;但是插入&lt;code&gt;b=0&lt;/code&gt;, &lt;code&gt;b=1&lt;/code&gt;, &lt;code&gt;b=5&lt;/code&gt;, &lt;code&gt;b=6&lt;/code&gt;时不会阻塞。&lt;/p&gt;

&lt;h2 id=&#34;相关&#34;&gt;相关&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.5/en/innodb-locking.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;14.10.1 InnoDB Locking&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为什么枚举是实现单例最好的方式？</title>
      <link>http://vonzhou.com/2019/enum-singleton/</link>
      <pubDate>Thu, 14 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://vonzhou.com/2019/enum-singleton/</guid>
      <description>

&lt;p&gt;提到单例模式（Singleton Pattern），都能说出一二，但是没那么简单。&lt;/p&gt;

&lt;h2 id=&#34;实现单例的方式&#34;&gt;实现单例的方式&lt;/h2&gt;

&lt;p&gt;本文代码&lt;a href=&#34;https://github.com/vonzhou/learning-java/tree/master/src/lang/enumsingleton&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;在这里&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;法1-静态成员&#34;&gt;法1：静态成员&lt;/h3&gt;

&lt;p&gt;不多说。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Singleton1 {
    public static final Singleton1 INSTANCE = new Singleton1();

    private Singleton1() {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;法2-静态工厂&#34;&gt;法2：静态工厂&lt;/h3&gt;

&lt;p&gt;和法1一样，只不过通过工厂方法来返回实例，在API设计上更可取。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Singleton2 {
    private static final Singleton2 INSTANCE = new Singleton2();

    private Singleton2() {
    }

    public static Singleton2 getInstance() {
        return INSTANCE;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;法3-lazy-initialization-延迟初始化&#34;&gt;法3：lazy initialization 延迟初始化&lt;/h3&gt;

&lt;p&gt;前面法1，法2是饿汉式，lazy initialization 是懒汉式，需要的时候实例化，另外 double check。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Singleton3 {
    private static Singleton3 INSTANCE = null;

    private Singleton3() {
    }

    public static Singleton3 getInstance() {
        if (INSTANCE == null) {
            synchronized (Singleton3.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton3();
                }
            }
        }
        return INSTANCE;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这3种方法思路是一样的，都是把构造器搞成私有的，控制实例化的过程。但是 &lt;code&gt;private constructor&lt;/code&gt; 是可以被绕过的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;序列化，反序列化&lt;/li&gt;
&lt;li&gt;反射&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;序列化&#34;&gt;序列化&lt;/h3&gt;

&lt;p&gt;Singleton1实例序列化，然后反序列化会得到一个不同的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Singleton1 implements Serializable {
    public static final Singleton1 INSTANCE = new Singleton1();

    private Singleton1() {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SingletonSerializationDemo {

    public static void main(String[] args) {
        // 对于Singleton2, 对于Singleton3 表现是一样的
        Singleton1 obj1 = Singleton1.INSTANCE;
        Singleton1 obj2 = Singleton1.INSTANCE;
        System.out.println(obj1 == obj2 ? &amp;quot;Two objects are same&amp;quot; : &amp;quot;Two objects are different&amp;quot;);

        // 序列化 obj1
        try {
            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&amp;quot;out.ser&amp;quot;));
            out.writeObject(obj1);
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }


        Singleton1 obj3 = null;
        try {
            ObjectInputStream in = new ObjectInputStream(new FileInputStream(&amp;quot;out.ser&amp;quot;));
            obj3 = (Singleton1) in.readObject();
            in.close();
        } catch (Exception i) {
            i.printStackTrace();
        }

        System.out.println(obj1 == obj3 ? &amp;quot;Two objects are same&amp;quot; : &amp;quot;Two objects are different&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Two objects are same
Two objects are different
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以这样就违背了单例的初衷。为了使得反序列化后的对象是同一个，我们可以提供&lt;code&gt;readResolve&lt;/code&gt;方法，会在反序列过程中被调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Singleton1 implements Serializable {
    public static final Singleton1 INSTANCE = new Singleton1();

    private Singleton1() {
    }

    // 注释掉该方法， 进行对比
    protected Object readResolve() {
        return INSTANCE;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Two objects are same
Two objects are same
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;反射&#34;&gt;反射&lt;/h3&gt;

&lt;p&gt;面对反射，private constructor也是无能为力。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SingletonReflectionDemo {
    public static void main(String[] args) throws Exception {
        Singleton1 obj1 = Singleton1.INSTANCE;
        // 得到无参构造器
        Constructor constructor = obj1.getClass().getDeclaredConstructor(new Class[0]);
        // 这里使私有构造器可以访问
        constructor.setAccessible(true);
        Singleton1 obj2 = (Singleton1) constructor.newInstance();
        System.out.println(obj1 == obj2 ? &amp;quot;Two objects are same&amp;quot; : &amp;quot;Two objects are different&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Two objects are different
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么面对序列化，反射，有没有更好实现Singleton的方式？enum&amp;hellip;..&lt;/p&gt;

&lt;h2 id=&#34;enum是实现单例最好的方式-法4&#34;&gt;enum是实现单例最好的方式（法4）&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum SingletonUsingEnum {
    INSTANCE
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;反序列化得到的也是同一个实例。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SingletonUsingEnumSerializationDemo {
    public static void main(String[] args) {
        SingletonUsingEnum obj1 = SingletonUsingEnum.INSTANCE;

        // 序列化 obj1
        try {
            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&amp;quot;out.ser&amp;quot;));
            out.writeObject(obj1);
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }


        SingletonUsingEnum obj3 = null;
        try {
            ObjectInputStream in = new ObjectInputStream(new FileInputStream(&amp;quot;out.ser&amp;quot;));
            obj3 = (SingletonUsingEnum) in.readObject();
            in.close();
        } catch (Exception i) {
            i.printStackTrace();
        }
        System.out.println(obj1 == obj3 ? &amp;quot;Two objects are same&amp;quot; : &amp;quot;Two objects are different&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Two objects are same
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用反射创建Enum实例的时候，会抛出异常。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SingletonUsingEnumReflectionDemo {
    public static void main(String[] args) throws Exception {
        SingletonUsingEnum obj1 = SingletonUsingEnum.INSTANCE;
        Constructor constructor = obj1.getClass().getDeclaredConstructors()[0];
        constructor.setAccessible(true);
        SingletonUsingEnum obj2 = (SingletonUsingEnum) constructor.newInstance();
        System.out.println(obj1 == obj2 ? &amp;quot;Two objects are same&amp;quot; : &amp;quot;Two objects are different&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects
	at java.lang.reflect.Constructor.newInstance(Constructor.java:417)
	at lang.enumsingleton.SingletonUsingEnumReflectionDemo.main(SingletonUsingEnumReflectionDemo.java:16)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;枚举是一个语法糖&#34;&gt;枚举是一个语法糖&lt;/h2&gt;

&lt;p&gt;一个例子开始。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum ColorEnum {
    RED,
    BLUE
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对class文件进行反编译， &lt;code&gt;javap -v ColorEnum.class&lt;/code&gt; 输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Classfile /D:/GitHub/learning-java/target/classes/lang/ColorEnum.class
  Last modified 2019-2-14; size 898 bytes
  MD5 checksum 79dff593c44747f1648cd48465351caf
  Compiled from &amp;quot;ColorEnum.java&amp;quot;
public final class lang.ColorEnum extends java.lang.Enum&amp;lt;lang.ColorEnum&amp;gt;
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_FINAL, ACC_SUPER, ACC_ENUM
Constant pool:
   #1 = Fieldref           #4.#36         // lang/ColorEnum.$VALUES:[Llang/ColorEnum;
   #2 = Methodref          #37.#38        // &amp;quot;[Llang/ColorEnum;&amp;quot;.clone:()Ljava/lang/Object;
   #3 = Class              #17            // &amp;quot;[Llang/ColorEnum;&amp;quot;
   #4 = Class              #39            // lang/ColorEnum
   #5 = Methodref          #12.#40        // java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;
   #6 = Methodref          #12.#41        // java/lang/Enum.&amp;quot;&amp;lt;init&amp;gt;&amp;quot;:(Ljava/lang/String;I)V
   #7 = String             #13            // RED
   #8 = Methodref          #4.#41         // lang/ColorEnum.&amp;quot;&amp;lt;init&amp;gt;&amp;quot;:(Ljava/lang/String;I)V
   #9 = Fieldref           #4.#42         // lang/ColorEnum.RED:Llang/ColorEnum;
  #10 = String             #15            // BLUE
  #11 = Fieldref           #4.#43         // lang/ColorEnum.BLUE:Llang/ColorEnum;
  #12 = Class              #44            // java/lang/Enum
  #13 = Utf8               RED
  #14 = Utf8               Llang/ColorEnum;
  #15 = Utf8               BLUE
  #16 = Utf8               $VALUES
  #17 = Utf8               [Llang/ColorEnum;
  #18 = Utf8               values
  #19 = Utf8               ()[Llang/ColorEnum;
  #20 = Utf8               Code
  #21 = Utf8               LineNumberTable
  #22 = Utf8               valueOf
  #23 = Utf8               (Ljava/lang/String;)Llang/ColorEnum;
  #24 = Utf8               LocalVariableTable
  #25 = Utf8               name
  #26 = Utf8               Ljava/lang/String;
  #27 = Utf8               &amp;lt;init&amp;gt;
  #28 = Utf8               (Ljava/lang/String;I)V
  #29 = Utf8               this
  #30 = Utf8               Signature
  #31 = Utf8               ()V
  #32 = Utf8               &amp;lt;clinit&amp;gt;
  #33 = Utf8               Ljava/lang/Enum&amp;lt;Llang/ColorEnum;&amp;gt;;
  #34 = Utf8               SourceFile
  #35 = Utf8               ColorEnum.java
  #36 = NameAndType        #16:#17        // $VALUES:[Llang/ColorEnum;
  #37 = Class              #17            // &amp;quot;[Llang/ColorEnum;&amp;quot;
  #38 = NameAndType        #45:#46        // clone:()Ljava/lang/Object;
  #39 = Utf8               lang/ColorEnum
  #40 = NameAndType        #22:#47        // valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;
  #41 = NameAndType        #27:#28        // &amp;quot;&amp;lt;init&amp;gt;&amp;quot;:(Ljava/lang/String;I)V
  #42 = NameAndType        #13:#14        // RED:Llang/ColorEnum;
  #43 = NameAndType        #15:#14        // BLUE:Llang/ColorEnum;
  #44 = Utf8               java/lang/Enum
  #45 = Utf8               clone
  #46 = Utf8               ()Ljava/lang/Object;
  #47 = Utf8               (Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;
{
  public static final lang.ColorEnum RED;
    descriptor: Llang/ColorEnum;
    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL, ACC_ENUM

  public static final lang.ColorEnum BLUE;
    descriptor: Llang/ColorEnum;
    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL, ACC_ENUM

  public static lang.ColorEnum[] values();
    descriptor: ()[Llang/ColorEnum;
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=0, args_size=0
         0: getstatic     #1                  // Field $VALUES:[Llang/ColorEnum;
         3: invokevirtual #2                  // Method &amp;quot;[Llang/ColorEnum;&amp;quot;.clone:()Ljava/lang/Object;
         6: checkcast     #3                  // class &amp;quot;[Llang/ColorEnum;&amp;quot;
         9: areturn
      LineNumberTable:
        line 7: 0

  public static lang.ColorEnum valueOf(java.lang.String);
    descriptor: (Ljava/lang/String;)Llang/ColorEnum;
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: ldc           #4                  // class lang/ColorEnum
         2: aload_0
         3: invokestatic  #5                  // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;
         6: checkcast     #4                  // class lang/ColorEnum
         9: areturn
      LineNumberTable:
        line 7: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      10     0  name   Ljava/lang/String;

  static {};
    descriptor: ()V
    flags: ACC_STATIC
    Code:
      stack=4, locals=0, args_size=0
         0: new           #4                  // class lang/ColorEnum
         3: dup
         4: ldc           #7                  // String RED
         6: iconst_0
         7: invokespecial #8                  // Method &amp;quot;&amp;lt;init&amp;gt;&amp;quot;:(Ljava/lang/String;I)V
        10: putstatic     #9                  // Field RED:Llang/ColorEnum;
        13: new           #4                  // class lang/ColorEnum
        16: dup
        17: ldc           #10                 // String BLUE
        19: iconst_1
        20: invokespecial #8                  // Method &amp;quot;&amp;lt;init&amp;gt;&amp;quot;:(Ljava/lang/String;I)V
        23: putstatic     #11                 // Field BLUE:Llang/ColorEnum;
        26: iconst_2
        27: anewarray     #4                  // class lang/ColorEnum
        30: dup
        31: iconst_0
        32: getstatic     #9                  // Field RED:Llang/ColorEnum;
        35: aastore
        36: dup
        37: iconst_1
        38: getstatic     #11                 // Field BLUE:Llang/ColorEnum;
        41: aastore
        42: putstatic     #1                  // Field $VALUES:[Llang/ColorEnum;
        45: return
      LineNumberTable:
        line 8: 0
        line 9: 13
        line 7: 26
}
Signature: #33                          // Ljava/lang/Enum&amp;lt;Llang/ColorEnum;&amp;gt;;
SourceFile: &amp;quot;ColorEnum.java&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义的枚举最终就是一个继承了&lt;code&gt;java.lang.Enum&lt;/code&gt;的类&lt;/li&gt;
&lt;li&gt;生成了2个静态方法&lt;code&gt;valueOf()&lt;/code&gt;, &lt;code&gt;values()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义了2个&lt;code&gt;static final&lt;/code&gt;变量 &lt;code&gt;RED&lt;/code&gt;, &lt;code&gt;BLUE&lt;/code&gt;，并且在静态块中进行了实例化&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;enum-分析&#34;&gt;Enum 分析&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://vonzhou.com/images/enum.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class Enum&amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; implements Comparable&amp;lt;E&amp;gt;, Serializable {
    private final String name;
    private final int ordinal;

    public final String name() {
        return this.name;
    }

    public final int ordinal() {
        return this.ordinal;
    }

    protected Enum(String var1, int var2) {
        this.name = var1;
        this.ordinal = var2;
    }

    public String toString() {
        return this.name;
    }

    public final boolean equals(Object var1) {
        return this == var1;
    }

    public final int hashCode() {
        return super.hashCode();
    }

    protected final Object clone() throws CloneNotSupportedException {
        throw new CloneNotSupportedException();
    }

    public final int compareTo(E var1) {
        if (this.getClass() != var1.getClass() &amp;amp;&amp;amp; this.getDeclaringClass() != var1.getDeclaringClass()) {
            throw new ClassCastException();
        } else {
            return this.ordinal - var1.ordinal;
        }
    }

    public final Class&amp;lt;E&amp;gt; getDeclaringClass() {
        Class var1 = this.getClass();
        Class var2 = var1.getSuperclass();
        return var2 == Enum.class ? var1 : var2;
    }

    public static &amp;lt;T extends Enum&amp;lt;T&amp;gt;&amp;gt; T valueOf(Class&amp;lt;T&amp;gt; var0, String var1) {
        Enum var2 = (Enum)var0.enumConstantDirectory().get(var1);
        if (var2 != null) {
            return var2;
        } else if (var1 == null) {
            throw new NullPointerException(&amp;quot;Name is null&amp;quot;);
        } else {
            throw new IllegalArgumentException(&amp;quot;No enum constant &amp;quot; + var0.getCanonicalName() + &amp;quot;.&amp;quot; + var1);
        }
    }

    // enum class 不能实现 finalize 方法，为什么？？
    protected final void finalize() {
    }

    private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException {
        throw new InvalidObjectException(&amp;quot;can&#39;t deserialize enum&amp;quot;);
    }

    private void readObjectNoData() throws ObjectStreamException {
        throw new InvalidObjectException(&amp;quot;can&#39;t deserialize enum&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来看看Enum的序列化，反序列化过程。&lt;/p&gt;

&lt;p&gt;Enum序列化的实现在&lt;code&gt;java.io.ObjectOutputStream.writeEnum&lt;/code&gt;中，可以看到&lt;strong&gt;只对枚举的名称进行了序列化&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void writeEnum(Enum&amp;lt;?&amp;gt; en,
                           ObjectStreamClass desc,
                           boolean unshared)
        throws IOException
    {
        bout.writeByte(TC_ENUM); // 特殊标记
        ObjectStreamClass sdesc = desc.getSuperDesc();
        writeClassDesc((sdesc.forClass() == Enum.class) ? desc : sdesc, false);
        handles.assign(unshared ? null : en);
        // 这里
        writeString(en.name(), false);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;反序列化的实现在&lt;code&gt;java.io.ObjectInputStream.readEnum&lt;/code&gt;，读出Enum的name之后，从常量字典中查找出对应的枚举常量，保证了唯一性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Enum&amp;lt;?&amp;gt; readEnum(boolean unshared) throws IOException {
        if (bin.readByte() != TC_ENUM) {
            throw new InternalError();
        }

        ObjectStreamClass desc = readClassDesc(false);
        if (!desc.isEnum()) {
            throw new InvalidClassException(&amp;quot;non-enum class: &amp;quot; + desc);
        }

        int enumHandle = handles.assign(unshared ? unsharedMarker : null);
        ClassNotFoundException resolveEx = desc.getResolveException();
        if (resolveEx != null) {
            handles.markException(enumHandle, resolveEx);
        }

        String name = readString(false);
        Enum&amp;lt;?&amp;gt; result = null;
        Class&amp;lt;?&amp;gt; cl = desc.forClass();
        if (cl != null) {
            try {
                // 关键代码
                @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
                Enum&amp;lt;?&amp;gt; en = Enum.valueOf((Class)cl, name);
                result = en;
            } catch (IllegalArgumentException ex) {
                throw (IOException) new InvalidObjectException(
                    &amp;quot;enum constant &amp;quot; + name + &amp;quot; does not exist in &amp;quot; +
                    cl).initCause(ex);
            }
            if (!unshared) {
                handles.setObject(enumHandle, result);
            }
        }

        handles.finish(enumHandle);
        passHandle = enumHandle;
        return result;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，enum是实现单例最好的方式。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>大面积offset commit失败，导致不停Rebalance，大量消息重复消费的问题</title>
      <link>http://vonzhou.com/2019/kafka-consumer-rebalance-jitter/</link>
      <pubDate>Wed, 30 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://vonzhou.com/2019/kafka-consumer-rebalance-jitter/</guid>
      <description>

&lt;h2 id=&#34;场景&#34;&gt;场景&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://vonzhou.com/images/kafka-consumer-rebalance-jitter-1.png&#34; alt=&#34;消费流程&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用spring-kafka，Listener方法中把收到的消息投递到Disruptor队列中，然后Disruptor单Consumer把消息插入到DB中。&lt;/p&gt;

&lt;p&gt;采用的手动ACK。&lt;/p&gt;

&lt;h2 id=&#34;严重问题的出现&#34;&gt;严重问题的出现&lt;/h2&gt;

&lt;p&gt;新版本发布之时，接到大量的报警异常，Consumer不停的进行Rebalance，不停的进行分区重分配，offset提交失败。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;2019-01-29 23:59:24 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-kafka-consumer-1] ERROR o.a.k.c.c.i.ConsumerCoordinator.handle 550 - Error UNKNOWN_MEMBER_ID occurred while committing offsets for group xxxxx_group
2019-01-29 23:59:24 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-kafka-consumer-1] ERROR o.a.k.c.c.i.ConsumerCoordinator.onJoinPrepare 254 - User provided listener org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer$1 failed on partition revocation:
org.apache.kafka.clients.consumer.CommitFailedException: Commit cannot be completed due to group rebalance
	at org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler.handle(ConsumerCoordinator.java:552)
	at org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler.handle(ConsumerCoordinator.java:493)
	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler.onSuccess(AbstractCoordinator.java:665)
	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler.onSuccess(AbstractCoordinator.java:644)
	at org.apache.kafka.clients.consumer.internals.RequestFuture$1.onSuccess(RequestFuture.java:167)
	at org.apache.kafka.clients.consumer.internals.RequestFuture.fireSuccess(RequestFuture.java:133)
	at org.apache.kafka.clients.consumer.internals.RequestFuture.complete(RequestFuture.java:107)
	at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$RequestFutureCompletionHandler.onComplete(ConsumerNetworkClient.java:380)
	at org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:274)
	at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.clientPoll(ConsumerNetworkClient.java:320)
	at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:213)
	at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:193)
	at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:163)
	at org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.commitOffsetsSync(ConsumerCoordinator.java:358)
	at org.apache.kafka.clients.consumer.KafkaConsumer.commitSync(KafkaConsumer.java:968)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.ackImmediate(KafkaMessageListenerContainer.java:578)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.manualAck(KafkaMessageListenerContainer.java:559)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.handleManualAcks(KafkaMessageListenerContainer.java:550)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.processCommits(KafkaMessageListenerContainer.java:624)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.stopInvokerAndCommitManualAcks(KafkaMessageListenerContainer.java:504)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.access$900(KafkaMessageListenerContainer.java:221)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer$1.onPartitionsRevoked(KafkaMessageListenerContainer.java:297)
	at org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.onJoinPrepare(ConsumerCoordinator.java:250)
	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator.ensureActiveGroup(AbstractCoordinator.java:207)
	at org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.ensurePartitionAssignment(ConsumerCoordinator.java:311)
	at org.apache.kafka.clients.consumer.KafkaConsumer.pollOnce(KafkaConsumer.java:890)
	at org.apache.kafka.clients.consumer.KafkaConsumer.poll(KafkaConsumer.java:853)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:408)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.lang.Thread.run(Thread.java:745)
2019-01-29 23:59:24 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-kafka-consumer-1] INFO  o.a.k.c.c.i.AbstractCoordinator.handle 354 - Attempt to join group xxxxx_group failed due to unknown member id, resetting and retrying.
2019-01-29 23:59:48 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-kafka-consumer-4] INFO  o.a.k.c.c.i.AbstractCoordinator.handle 623 - Attempt to heart beat failed since the group is rebalancing, try to re-join group.
2019-01-29 23:59:48 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-kafka-consumer-4] INFO  o.s.k.l.KafkaMessageListenerContainer.onPartitionsRevoked 224 - partitions revoked:[]
2019-01-29 23:59:48 [org.springframework.kafka.KafkaListenerEndpointContainer#1-0-kafka-consumer-2] INFO  o.a.k.c.c.i.AbstractCoordinator.handle 623 - Attempt to heart beat failed since the group is rebalancing, try to re-join group.
2019-01-29 23:59:48 [org.springframework.kafka.KafkaListenerEndpointContainer#1-0-kafka-consumer-2] INFO  o.s.k.l.KafkaMessageListenerContainer.onPartitionsRevoked 224 - partitions revoked:[]
2019-01-29 23:59:48 [org.springframework.kafka.KafkaListenerEndpointContainer#1-0-kafka-consumer-1] INFO  o.a.k.c.c.i.AbstractCoordinator.handle 623 - Attempt to heart beat failed since the group is rebalancing, try to re-join group.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;offset提交失败，带来的问题就是大量的消息被重复消费，相互影响，不断恶化，导致消息堆积很严重，无法推进。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException: Duplicate record.
	at sun.reflect.GeneratedConstructorAccessor45.newInstance(Unknown Source)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
	at com.mysql.jdbc.Util.handleNewInstance(Util.java:411)
	at com.mysql.jdbc.Util.getInstance(Util.java:386)
	at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1041)
	at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:4120)
	at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:4052)
	at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:2503)
	at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2664)
	at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2815)
	at com.mysql.jdbc.PreparedStatement.executeInternal(PreparedStatement.java:2155)
	at com.mysql.jdbc.PreparedStatement.execute$sentryProxy(PreparedStatement.java:1379)
	at com.mysql.jdbc.PreparedStatement.execute(PreparedStatement.java)
	at com.alibaba.druid.pool.DruidPooledPreparedStatement.execute(DruidPooledPreparedStatement.java:493)
	at org.apache.ibatis.executor.statement.PreparedStatementHandler.update(PreparedStatementHandler.java:46)
	at org.apache.ibatis.executor.statement.RoutingStatementHandler.update(RoutingStatementHandler.java:74)
	at org.apache.ibatis.executor.SimpleExecutor.doUpdate(SimpleExecutor.java:50)
	at org.apache.ibatis.executor.BaseExecutor.update(BaseExecutor.java:117)
	at org.apache.ibatis.executor.CachingExecutor.update(CachingExecutor.java:76)
	at org.apache.ibatis.session.defaults.DefaultSqlSession.update(DefaultSqlSession.java:198)
	at org.apache.ibatis.session.defaults.DefaultSqlSession.insert(DefaultSqlSession.java:185)
	at sun.reflect.GeneratedMethodAccessor84.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:434)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;解决&#34;&gt;解决&lt;/h2&gt;

&lt;p&gt;出现&lt;code&gt;Error UNKNOWN_MEMBER_ID occurred while committing offsets for group&lt;/code&gt;的原因是在kafka consumer会话超时的时候，没有能把offset提交到broker，所以要么超时时间&lt;code&gt;session.timeout.ms&lt;/code&gt;设置的太短了，要么消息的处理太慢了影响了ACK的执行，要么虽然是采用了线程池的方式，但是consumer在把消息入队的时候阻塞了，从而影响ACK。&lt;/p&gt;

&lt;p&gt;所以总结下来解决的思路是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;调参 &lt;code&gt;session.timeout.ms&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;加快消息的消费速度，我推荐的方式是单Consumer拿到消息后放到一个队列中，多线程的方式进行消费处理，设置ShutdownHook保证关闭的时候队列中的消息不丢失&lt;/li&gt;
&lt;li&gt;采用自动commit的方式，但是有数据丢失的风险&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在我们的场景中，问题应该出在spring-kafka-listener取消息的速度过快，阻塞在把消息投递到Disruptor中，所以还有一点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;降低spring-kafka的并发度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最终的效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://vonzhou.com/images/kafka-consumer-rebalance-jitter-2.png&#34; alt=&#34;commit失败趋势图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Kafka的参数常用的要知道，不要盲目设置&lt;/li&gt;
&lt;li&gt;遇到问题无从下手的时候，看看源码，找到根源&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Nginx后端响应不完整问题分析</title>
      <link>http://vonzhou.com/2019/nginx-temp-file/</link>
      <pubDate>Fri, 04 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://vonzhou.com/2019/nginx-temp-file/</guid>
      <description>

&lt;p&gt;Nginx默认会开启proxy buffer，如果没有权限写临时文件，就会导致响应被截取。&lt;/p&gt;

&lt;h2 id=&#34;场景&#34;&gt;场景&lt;/h2&gt;

&lt;p&gt;实现了一个简单的文件存储服务器，可以上传，下载，为了使用简单，使用了Nginx配置了端口转发，这样访问时无需包含端口信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget http://10.240.208.36/api/v1/fileserv/download?objName=xxxxx.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是今天在下载文件时发现了一个问题，一个40M的文件，下载后只有100K了，关键在于只要经过Nginx访问就不完整，直接访问后端接口就是OK的，那么问题应该出在Nginx的配置方面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;nginx-temp-file-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在Nginx的错误日志中有如下的错误信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;2019/01/04 10:44:36 [crit] 14545#14545: *65 open() &amp;quot;/var/lib/nginx/proxy/5/00/0000000005&amp;quot; failed (13: Permission denied) while reading upstream, client: 10.240.208.36, server: _, request: &amp;quot;GET /api/v1/fileserv/download?objName=1546565995465_06a7c789611eb727cc95c529718e675e.apk HTTP/1.1&amp;quot;, upstream: &amp;quot;http://127.0.0.1:9197/api/v1/fileserv/download?objName=1546565995465_06a7c789611eb727cc95c529718e675e.apk&amp;quot;, host: &amp;quot;10.240.208.163&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动Nginx的用户无权限写 /var/lib/nginx/proxy 目录，导致后续的内容无法返回，所以下载的文件不完整。&lt;/p&gt;

&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;

&lt;p&gt;Nginx代理缓存（&lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_buffering&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;proxy_buffering&lt;/a&gt;）开启后（&lt;code&gt;proxy_buffering on&lt;/code&gt;，默认是开启的），当Nginx从后端服务器收到响应后，该response的前面部分会缓存起来（可以通过&lt;code&gt;proxy_buffer_size&lt;/code&gt;设置，默认是一个内存页大小，4K或者8K），如果buffer的大小无法容纳整个响应，剩下的部分会写到临时文件中，写临时文件可以通过选项 &lt;code&gt;proxy_max_temp_file_size&lt;/code&gt; 和 &lt;code&gt;proxy_temp_path&lt;/code&gt;控制，其中&lt;code&gt;proxy_max_temp_file_size&lt;/code&gt;控制临时文件的最大大小，如果设置为0则不会写临时文件，&lt;code&gt;proxy_temp_path&lt;/code&gt;设置临时文件的路径。&lt;/p&gt;

&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;

&lt;p&gt;Nginx配置，设置一个Nginx用户有权访问的临时目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;proxy_temp_path /home/appops/nginx_proxy_temp 1 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;nginx-temp-file-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;也可以通过禁用掉代理响应缓存来处理这种情况：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;proxy_max_temp_file_size 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;proxy_buffering off;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>《快学Scala》读书笔记</title>
      <link>http://vonzhou.com/2018/scala-impatient/</link>
      <pubDate>Mon, 31 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>http://vonzhou.com/2018/scala-impatient/</guid>
      <description>

&lt;p&gt;这本书我是2013年买的，当时看了一部分，然后又忘了，现在重新阅读。&lt;/p&gt;

&lt;p&gt;Scala将OOP和函数式编程有机结合，动静兼备。前面的基本招式通读后，基本上可以理解。但是后面的类型系统，协变型变，定界延续目前还搞不懂，暂时略过。&lt;/p&gt;

&lt;h2 id=&#34;1-基础&#34;&gt;1.基础&lt;/h2&gt;

&lt;p&gt;Scala解释器的使用。&lt;/p&gt;

&lt;p&gt;val,var声明值和变量。&lt;/p&gt;

&lt;p&gt;有7中数值类型：Byte,Char,Short,Int,Long,Float,Double,Boolean，和Java不同的是这些都是类。&lt;/p&gt;

&lt;p&gt;Scala中使用方法进行数值类型的转换，而不是强制类型转换。&lt;/p&gt;

&lt;p&gt;和&lt;code&gt;Java，C++&lt;/code&gt;不同的是，Scala中没有++,&amp;ndash;操作符，要使用+=1。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;()&lt;/code&gt;操作符背后的实现原理是&lt;code&gt;apply&lt;/code&gt;方法。&lt;/p&gt;

&lt;h2 id=&#34;2-控制结构和函数&#34;&gt;2.控制结构和函数&lt;/h2&gt;

&lt;p&gt;if表达式有值。&lt;/p&gt;

&lt;p&gt;{}块也有值，值是最后一个表达式的值。这个特性对于要分多步来初始化val的情况很有用。&lt;/p&gt;

&lt;p&gt;Unit等同于Java，C++中的void。&lt;/p&gt;

&lt;p&gt;赋值语句本身没有值，是Unit。&lt;/p&gt;

&lt;p&gt;定义函数的时候，最好不使用return。&lt;/p&gt;

&lt;p&gt;Scala中没有Checked Exception。&lt;/p&gt;

&lt;h2 id=&#34;3-数组相关操作&#34;&gt;3.数组相关操作&lt;/h2&gt;

&lt;p&gt;定长数组是Array, 变长数组是ArrayBuffer。&lt;/p&gt;

&lt;p&gt;用 &lt;code&gt;for(e &amp;lt;- arr)&lt;/code&gt; 遍历元素。&lt;/p&gt;

&lt;p&gt;用 &lt;code&gt;for(e &amp;lt;- arr if ...) yield ...&lt;/code&gt; 转换数组。&lt;/p&gt;

&lt;p&gt;Scala数组和Java数组互操作。&lt;/p&gt;

&lt;h2 id=&#34;4-映射和元组&#34;&gt;4.映射和元组&lt;/h2&gt;

&lt;p&gt;Scala中没有可变的树形映射，可以选择Java的TreeMap。&lt;/p&gt;

&lt;p&gt;元组可以用于函数需要返回不止一个值的情况。&lt;/p&gt;

&lt;h2 id=&#34;5-类&#34;&gt;5.类&lt;/h2&gt;

&lt;p&gt;Scala为每个字段生成&lt;code&gt;getter，setter&lt;/code&gt;方法，不过可以通过&lt;code&gt;private,val,var,private[this]&lt;/code&gt;控制这个过程。&lt;/p&gt;

&lt;p&gt;如果需要JavaBeans版的&lt;code&gt;getter，setter&lt;/code&gt;方法，可以使用BeanProperty注解。&lt;/p&gt;

&lt;p&gt;Scala中类有一个主构造器（primary constructor），任意多个辅助构造器（auxiliary constructor），名称是this。每个辅助构造器都必须开始于调用其他辅助构造器或者主构造器。&lt;/p&gt;

&lt;p&gt;练习5.注意BeanProperty包路径变了，&lt;code&gt;scala.beans.BeanProperty&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;➜  ch05 git:(master) scalac Student.scala  
➜  ch05 git:(master) javap -private Student
Compiled from &amp;quot;Student.scala&amp;quot;
public class Student {
  private java.lang.String name;
  private long id;
  public java.lang.String name();
  public void name_$eq(java.lang.String);
  public void setName(java.lang.String);
  public long id();
  public void id_$eq(long);
  public void setId(long);
  public java.lang.String getName();
  public long getId();
  public Student(java.lang.String, long);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-对象&#34;&gt;6.对象&lt;/h2&gt;

&lt;p&gt;在Java中会使用单例对象的地方，Scala中用对象，单例模式。&lt;/p&gt;

&lt;p&gt;搞清类和伴生对象（companion object）的关系。&lt;/p&gt;

&lt;p&gt;定义枚举的方法。&lt;/p&gt;

&lt;h2 id=&#34;7-包和引入&#34;&gt;7.包和引入&lt;/h2&gt;

&lt;p&gt;包对象（package object）。&lt;/p&gt;

&lt;p&gt;可以在任何地方声明包引入。&lt;/p&gt;

&lt;h2 id=&#34;8-继承&#34;&gt;8.继承&lt;/h2&gt;

&lt;p&gt;要知道Scala的继承层级。&lt;/p&gt;

&lt;p&gt;能看懂，但是自己怕是写不出来，需要练习。&lt;/p&gt;

&lt;h2 id=&#34;9-文件和正则表达式&#34;&gt;9.文件和正则表达式&lt;/h2&gt;

&lt;p&gt;用完Source对象，要记得close。&lt;/p&gt;

&lt;p&gt;如果要查看某个字符，但是不处理掉它，使用source.buffered方法（类似C++中的&lt;code&gt;istream::peek&lt;/code&gt;，或java中的&lt;code&gt;PushbackInputStream&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;Scala没有提供读取二进制文件的方法，要使用java类库。写文件也要使用java库&lt;code&gt;java.io.PrintWriter&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;可以编写shell脚本。&lt;/p&gt;

&lt;h2 id=&#34;10-特质&#34;&gt;10.特质&lt;/h2&gt;

&lt;p&gt;Scala和Java不能多重继承（菱形继承问题）。&lt;/p&gt;

&lt;p&gt;特质可以同时拥有抽象方法和具体方法，类可以实现多个特质。&lt;/p&gt;

&lt;p&gt;实现特质用的extends，而不是implements，实现多个特质用with（奇怪么? &lt;code&gt;extends A with B&lt;/code&gt;，&lt;code&gt;A with B&lt;/code&gt;先是一个整体，然后由类扩展）。所有Java接口都可作为Scala的trait使用。&lt;/p&gt;

&lt;p&gt;注意引入特质后，类的构造器执行顺序。&lt;/p&gt;

&lt;p&gt;特质不能有构造器参数。&lt;/p&gt;

&lt;p&gt;自身类型（self type）可以解决特质间的循环依赖。&lt;/p&gt;

&lt;h2 id=&#34;11-操作符&#34;&gt;11.操作符&lt;/h2&gt;

&lt;p&gt;操作符的优先级。&lt;/p&gt;

&lt;p&gt;apply, update可以简化方法的调用。&lt;/p&gt;

&lt;p&gt;unapply，unapplySeq和模式匹配的关系。&lt;/p&gt;

&lt;h2 id=&#34;12-高阶函数&#34;&gt;12.高阶函数&lt;/h2&gt;

&lt;p&gt;函数是一等公民。&lt;/p&gt;

&lt;h2 id=&#34;13-集合&#34;&gt;13.集合&lt;/h2&gt;

&lt;p&gt;所有集合都扩展自Iterable trait。&lt;/p&gt;

&lt;p&gt;Java中ArrayList和LinkedList实现了共同的List接口，使得编写要考虑随机访问效率的代码比较困难，后来加入的RandomAccess（1.4）就是应对这个的。&lt;/p&gt;

&lt;p&gt;Scala优先采用不可变集合。&lt;/p&gt;

&lt;h2 id=&#34;14-模式匹配和样例类&#34;&gt;14.模式匹配和样例类&lt;/h2&gt;

&lt;p&gt;Scala中模式匹配match无需在每个分支后面break。&lt;/p&gt;

&lt;p&gt;支持守卫，而无需把每种情况的case都列出来。&lt;/p&gt;

&lt;p&gt;倾向于使用类型模式匹配，而不是isInstanceOf操作符。匹配发生在运行时，所以泛型会擦除。&lt;/p&gt;

&lt;p&gt;模式匹配用于数组，列表，元组背后是提取器机制，对应的伴生对象实现unapply，unapplySeq方法。比如Array的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;/** Called in a pattern match like `{ case Array(x,y,z) =&amp;gt; println(&#39;3 elements&#39;)}`.
   *
   *  @param x the selector value
   *  @return  sequence wrapped in a [[scala.Some]], if `x` is a Seq, otherwise `None`
   */
  def unapplySeq[T](x: Array[T]): Option[IndexedSeq[T]] =
    if (x == null) None else Some(x.toIndexedSeq)
    // !!! the null check should to be necessary, but without it 2241 fails. Seems to be a bug
    // in pattern matcher.  @PP: I noted in #4364 I think the behavior is correct.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;样例类（&lt;code&gt;Case Class&lt;/code&gt;）的使用场景和作用。List就是用样例类实现的。&lt;/p&gt;

&lt;p&gt;推荐使用Option表示可有可无的东西。&lt;/p&gt;

&lt;h2 id=&#34;15-注解&#34;&gt;15.注解&lt;/h2&gt;

&lt;p&gt;Annotation，StaticAnnotation, ClassfileAnnotation。&lt;/p&gt;

&lt;h2 id=&#34;17-类型参数&#34;&gt;17.类型参数&lt;/h2&gt;

&lt;p&gt;类型变量界定，上界&lt;code&gt;&amp;lt;:&lt;/code&gt;，下界&lt;code&gt;&amp;gt;:&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;视图界定&lt;code&gt;&amp;lt;%&lt;/code&gt;，表示可以隐式转换的情况。&lt;/p&gt;

&lt;p&gt;要实例化一个&lt;code&gt;Array[T]&lt;/code&gt;,需要一个&lt;code&gt;Manifest[T]&lt;/code&gt;对象，这么复杂？因为JVM中泛型擦除。&lt;/p&gt;

&lt;h2 id=&#34;课后习题编程&#34;&gt;课后习题编程&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/vonzhou/ScalaImpatient&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;读于 2018.12.29 杭州&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>